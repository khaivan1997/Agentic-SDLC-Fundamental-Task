# MCP Server — Architecture & Requirements Analysis

## 1. What is the MCP Server?

The Model Context Protocol (MCP) is an open standard that gives AI agents (Claude, GPT-4o, etc.) a standardized way to discover and use external tools. In MCP terminology:

- **Tool** = A function the AI can call (equivalent to an API endpoint).
- **Resource** = Read-only data the AI can inspect (e.g., database schema).
- **MCP Server** = The application that exposes Tools and Resources to the AI.

The MCP Server is NOT part of the main application flow. It is used only by an AI agent to read/write data into the shared database.

## 2. Architecture Overview

```
[ Human User ]          [ AI Agent (Claude/GPT) ]
       |                          |
       v                          v
[ React Frontend ]      [ MCP Server (Spring Boot) ]
       |                          |
       v                          |
[ Task Backend API ]              |
       |                          |
       v                          v
       +--- [ PostgreSQL DB ] ----+
            (shared database)
```

Key points:
- The MCP Server is a **fully separate Maven module and Spring Boot application** (`mcp-server/`) running on its own port (`8081`).
- Shared code (`Task` entity, `TaskStatus` enum, `TaskRepository`) lives in a common `api-models` module — no duplication between backend and mcp-server.
- Both the main backend and the MCP server connect to the **same PostgreSQL database** using identical connection credentials.
- The MCP Server exposes tools via the MCP protocol (SSE transport over HTTP) — NOT regular REST APIs.
- The main backend continues to serve the React frontend and REST API on port `8080`.

## 3. Technology Stack

- **Framework**: Spring Boot 3.4.x (Java 17+)
- **MCP SDK**: Spring AI MCP Server Boot Starter (`spring-ai-starter-mcp-server-webmvc`) via `spring-ai.version=1.1.0-M2`
- **Underlying MCP Java SDK**: `io.modelcontextprotocol.sdk:mcp` 0.13.1+ (supports MCP spec `2025-06-18`)
- **Transport**: SSE (Server-Sent Events) over WebMVC
- **Database**: PostgreSQL (shared with the Task Backend)
- **Database Access**: Spring Data JPA / Hibernate
- **Spec Version**: MCP 2025-06-18
- **Important**: `spring.ai.mcp.server.version` is server metadata; MCP spec compliance must be validated from `initialize` negotiated `protocolVersion`.
- **Optional**: SpringDoc OpenAPI (`/swagger-ui`) for documentation

## 4. MCP Tools (Functional Requirements from request-ext.txt)

The MCP Server must expose 4 tools to the AI agent:

| Tool Name           | Type       | Description                                                                 |
| :------------------ | :--------- | :-------------------------------------------------------------------------- |
| `mcp-help`          | Read-only  | Returns a short, agent-readable description of all available tools.         |
| `mcp-schema-tasks`  | Read-only  | Returns the database schema for the `tasks` table as a simplified JSON-Schema (field names, types, constraints). |
| `mcp-tasks`         | Write      | Accepts a JSON array of Task objects and bulk-inserts them into the DB.     |
| `mcp-tasks-summary` | Read-only  | Returns summary statistics: total task count and count per status (TODO, IN_PROGRESS, DONE). |

## 5. Implementation Approach (Spring AI MCP Annotations)

Instead of manually implementing JSON-RPC, we use the **Spring AI MCP Server Boot Starter** which provides annotation-based tool registration:

```java
@Component
public class TaskMcpTools {

    @McpTool(name = "mcp-schema-tasks", description = "Returns the task table schema as JSON-Schema")
    public Map<String, Object> schemaTasks() { ... }

    @McpTool(name = "mcp-tasks", description = "Bulk insert tasks into the database")
    public Map<String, Object> insertTasks(@McpToolParam(description = "JSON array of task objects") List<TaskInput> tasks) { ... }

    @McpTool(name = "mcp-tasks-summary", description = "Returns task count statistics grouped by status")
    public TaskSummary tasksSummary() { ... }

    @McpTool(name = "mcp-help", description = "Returns a description of all available tools")
    public Map<String, Object> help() { ... }
}
```

The Spring AI starter automatically:
1. Scans for `@McpTool` annotated methods.
2. Generates JSON schemas for their parameters.
3. Registers them with the MCP protocol handler.
4. Serves them over SSE transport at the configured endpoint.

## 6. Database Migration (H2 → PostgreSQL)

### Why?
The requirement explicitly states "PostgreSQL DB (shared with Task Backend)". The MCP server needs to read/write the same `tasks` table that the main backend uses.

### How?
- Add a `docker-compose.yml` to spin up a PostgreSQL container.
- Update `backend/application.properties` to use the PostgreSQL driver and connection URL.
- The MCP server module will use the same connection config.

### Docker Compose:
```yaml
services:
  postgres:
    image: postgres:latest
    ports:
      - "5436:5432"
    environment:
      POSTGRES_DB: taskdb
      POSTGRES_USER: taskuser
      POSTGRES_PASSWORD: taskpass
```

### application.properties (both backend and mcp-server):
```
spring.datasource.url=jdbc:postgresql://localhost:5436/taskdb
spring.datasource.username=taskuser
spring.datasource.password=taskpass
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
```

## 7. Project Structure

```
CDSLFreeAgent/
├── docker-compose.yml           (NEW — PostgreSQL container)
├── pom.xml                      (Root Parent POM — 4 modules)
├── api-models/                  (NEW — shared Java module)
│   ├── pom.xml                  (spring-boot-starter-data-jpa, validation)
│   └── src/main/java/com/taskmanager/
│       ├── model/
│       │   ├── Task.java               (shared JPA entity)
│       │   └── TaskStatus.java         (shared enum)
│       └── repository/
│           └── TaskRepository.java     (shared JpaRepository + countByStatus)
├── frontend/                    (unchanged)
├── backend/                     (depends on api-models — no local entity/repo)
│   ├── pom.xml
│   └── src/main/
│       ├── java/com/taskmanager/
│       │   ├── BackendApplication.java
│       │   ├── controller/TaskController.java
│       │   ├── service/TaskService.java
│       │   ├── config/CorsConfig.java
│       │   └── exception/...
│       └── resources/application.properties
└── mcp-server/                  (depends on api-models — no local entity/repo)
    ├── pom.xml                  (spring-ai-starter-mcp-server-webmvc, postgresql)
    └── src/main/
        ├── java/com/taskmanager/mcp/
        │   ├── McpServerApplication.java   (@EntityScan + @EnableJpaRepositories)
        │   ├── tools/
        │   │   └── TaskMcpTools.java       (@McpTool annotated methods)
        │   └── dto/
        │       ├── TaskInput.java
        │       └── TaskSummary.java
        └── resources/application.properties
```

The MCP server runs on port `8081` (configured via `server.port=8081`) so it does not conflict with the main backend on `8080`.

## 8. AI Agent Interaction Flow

1. Agent connects to MCP server via SSE transport.
2. Agent calls `mcp-help` → learns what tools are available.
3. Agent calls `mcp-schema-tasks` → learns the Task entity structure (id, title, description, status, dueDate).
4. Agent generates 1000 realistic Task objects with random titles, descriptions, statuses, and due dates.
5. Agent calls `mcp-tasks` with the JSON array → bulk insert into PostgreSQL.
6. Agent calls `mcp-tasks-summary` → verifies the insertion (expects ~1000 total, distributed across statuses).

## 9. Success Criteria (from request-ext.txt)

1. MCP Server is running, accessible, and negotiates MCP protocol version 2025-06-18.
2. Schema inspection works via `mcp-schema-tasks`.
3. AI agent inserts 1000 task records via `mcp-tasks`.
4. Summary endpoint reflects the inserted data (shows 1000 tasks split across statuses).
5. All actions are documented, including prompts, AI output, and results.
